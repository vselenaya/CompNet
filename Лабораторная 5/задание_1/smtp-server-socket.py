import socket
import ssl
import base64


# данные для почтового ящика указываем:
my_mail = "***"
my_pass = "***"
mail_server = ('smtp.gmail.com', 587)
need_TLS = True


# уже использовавшаяся нами функция получения данных из сокета:
def get_data(socket_connection, timelimit=1):
    data = ""
    socket_connection.settimeout(timelimit)  # устанавливаем timelimit, надеясь, что сервер успеет сформулировать
    # за это время ответа и прислать нам... если не успеет - мы его проигнорируем (так что если это происходит
    # медленно, стоит увеличить таймер)

    while True:
        try:
            data_slice = socket_connection.recv(1024)
        except socket.timeout:
            data_slice = None
        if data_slice:
            data += data_slice.decode("utf-8")
        else:
            break
    return data


print("Введите адрес получателя:")
destination = input()
print()
if destination == "":
    destination = "default dest"

print("Начинаем установку соединения...")
print()
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
try:
    sock.connect(mail_server)  # подключаемся к почтовому серверу
    print(get_data(sock, timelimit=2))  # получаем от него ответ

    # этот кусок нужен, если почтовым сервером требуется защищенное соединение SSL:
    # (это позволяет не так беспокоиться о передаваемом по tcp паролю..... - он будет шифрован)
    if need_TLS:
        command = "HELO smtp-server\r\n"  # сначала здороваемся с сервером (команда HELO с чем угодно)
        print("   " + command)
        sock.sendall(command.encode("utf-8"))  # все команды мы отправляем в кодировке utf-8 (чтобы русский текст
        # поддерживался и тд...) - хотя smtp вроде требует ascii формат, но с utf-8 тоже работает
        print(get_data(sock))

        command = "STARTTLS\r\n"  # затем инициирцем подключение SSL/TLS на стороне сервера
        print("   " + command)
        sock.sendall(command.encode("utf-8"))
        print(get_data(sock))
        sock = ssl.wrap_socket(sock)  # после того, как сервер попросили включить защищённое соединение,
        # оборачиваем свой клиентский сокет sock в специальную обертку, чтобы мы отправляли данные шифрованно с SSL/TLS

    # а далее просто цикл общения с сервером: передаём ему команду command (заметим, для smtp-сервера все строки
    # команд должны заканчиваться на \r\n) и получаем ответ:
    for command in ["HELO smtp-server\r\n",  # несмотря на то, что мы могли уже поздороваться (if need_TLS), после
                                             # включения TLS здороваться нужно ещё раз...
                    "AUTH LOGIN\r\n",  # это команда запускает процесс аутентификации нас на почтовом сервере -
                                       # - не очень понятно, зачем, но после этой команды и до конца аутентификации
                                       # smtp-сервер общается только в кодировке base64 (чем его как до этого
                                       # ascii/utf-8 не устраивает - непонятно.....)
                    base64.b64encode(my_mail.encode("utf-8")).decode("utf-8") + "\r\n",  # передаём логин
                    base64.b64encode(my_pass.encode("utf-8")).decode("utf-8") + "\r\n",  # и пароль (всё в base64!!!!!)
                    "MAIL FROM: <{}>\r\n".format(my_mail),  # откуда отправляем
                    "RCPT TO: <{}>\r\n".format(destination),  # куда отправляем
                    "DATA\r\n",
                    "__enter_message__",
                    "QUIT\r\n"]:

        if command == "__enter_message__":  # тут построчно вводим текст письма, которое хотим отправить:
            print("Введите текст письма (txt-формат), а на последней строке - один символ точка:")
            while True:
                line = input()
                sock.sendall((line + "\r\n").encode("utf-8"))  # каждую строчку ввода сразу отправляем на smtp-сервер
                if line == ".":  # если это была точка (её тоже на сервер отправили как символ конца ввода),
                    print(get_data(sock))  # итаем ответ
                    break
            continue

        print("   " + command)  # выводим отправляемую нами команду
        sock.sendall(command.encode("utf-8"))
        print(get_data(sock))  # выводим ответ сервера
finally:
    sock.close()


"""
Комментарий по письму:
Если хочется написать письмо, которое для получателя в почтовом сервисе будет отображаться как отправленное не с вашего,
а с другого почтового ящика или будет отображаться как отправленное не ему, а также если хочется добавить тему письма,
то всё это указывается в самом теле письма (которое мы вводим после строки if command == "__enter_message__":) -
- а именно в заголовке (который от основного псьма отделён одной строкой) в полях From:, To: и Subject: (те команды,
которые мы пишем на сервер (MAIL FROM и RCPT TO) - это настоящие команды, в них должны быть прописаны настоящий
отправитель и получатель; а уже как будет отображаться... - это задаём в теле письма)

Пример письма:
From: Жаба Полосатая
To: lygushka_patnystaya@mail.ru
Subject: о разном...

Привет!
Как дела?

- вот такое письмо будет отображаться у получателя как отправленное от "Жаба Полосатая" к "lygushka_patnystaya@mail.ru"
(вне зависимости с каких и на какие на самом деле адрема письмо было отправлено...), а тема будет "о разном...".
--------------------------------

На самом деле, у меня не получилось с помощью поля From: подменить реального отправителя (то есть меня) для получателя,
хотя поля To: и Subject: работают.... То ли дело в том, что современные почтовые сервера (yandex, mail, gmail) 
отображают реального отправителя (а не того, который в поле From:), то ли сервис gmail (через который я тестировал
программу) подменяет моё поле From: на реального отправителя..... 
"""
